---
title: "Introduction to the QCArobust package"
author: "Ingo Rohlfing, Ayjeren Rozyjumayeva"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the QCArobust package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r load package}
library(QCArobust)
```

## Illustration using Skaaning (2011)
We use the original robustness analysis by Skaaning to illustrate the main functions. (Skaaning, Svend-Erik (2011): Assessing the Robustness of Crisp-Set and Fuzzy-Set QCA Results. *Sociological Methods & Research* 40 (2): 391-408. [published version](http://10.1177/0049124111404818)).
We import a list of solutions presented in table 3 of the article. It  summarizes results for the choice of different calibration anchors for crisp-set QCA.
```{r Skaaning csqca anchors}
# Loading Skaaning (2011) data from table 3
data("Skaaning_table3")
```

### Analysis of solutions
On the most highly aggregated level of analysis, `sols_plot()` either produces a bar chart plotting the frequency of solutions or a dataframe with solutions and their frequencies. 
```{r}
sols_plot(Skaaning_table3)
sols_plot(Skaaning_table3, plot = T, plot_solutions = 3)
```


On the second, medium level of aggregation, the solutions are decomposed into their configurations. The `config_upset()` function serves this purpose. This should be used now with the config_upset_h() version of the function.
```{r}
#skaaning_configs <- config_upset(Skaaning_csanchors, nsets = 100)
#png("Skaaning_configs.png", width = 600, height = 400, res = "100")
#print(skaaning_configs)
#dev.off()
```

```{r, fig.width = 7, fig.height = 5}
skaaning_conds <- conds_upset(Skaaning_table3, nsets = 200)
skaaning_conds
```

Applying the functions to Krogslund et al. (PA, 2015)
Initially on the naive model 1 (referred to as ka_model_1_sim)

```{r, eval = F}
model_1 <- read.csv("ka_model_1_sim.csv")

#conditions
kcp <- conds_upset(model_1$Configurations, nsets = 200)
conds_upset(model_1$Configurations, nsets = 162)

```


The rest of the models (titled for the sake of clarity as model_n)
model_1 (is the model presented in the chunk above).

```{r,eval=F}
model_2 <- read.csv("ka_model_1_ncut1_error.csv")
model_3 <- read.csv("model_2_ncut1_error.csv")
model_4 <- read.csv("model_2_sim.csv")
model_5 <- read.csv("model_ncut2_error.csv")
model_6 <- read.csv("model_sim.csv")
```

Conditions function
```{r, eval = F}
conds_upset(model_2$Configurations, nsets = 200)
conds_upset(model_3$Configurations, nsets = 500)
conds_upset(model_4$Configurations, nsets = 300)
conds_upset(model_5$Configurations, nsets = 400)
conds_upset(model_6$Configurations, nsets = 500)
```


Configurations applied
```{r, eval = F}
config_upset(model_2$Configurations, nsets = 300)
config_upset(model_3$Configurations, nsets = 300)
config_upset(model_4$Configurations, nsets = 400)
config_upset(model_5$Configurations, nsets = 500)
config_upset(model_6$Configurations, nsets = 400)

```










