---
title: "Introduction to the QCArobust package"
author: "Ingo Rohlfing, Ayjeren Rozyjumayeva"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the QCArobust package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r load package, warning = F, message = F}
library(QCArobust)
library(formattable) # nicer html tables
```

## Illustration using Skaaning (2011)
We use the original robustness analysis by Skaaning to illustrate the main functions. (Skaaning, Svend-Erik (2011): Assessing the Robustness of Crisp-Set and Fuzzy-Set QCA Results. *Sociological Methods & Research* 40 (2): 391-408. [published version](http://10.1177/0049124111404818)).
We import a list of solutions presented in table 3 of the article. It  summarizes results for the choice of different calibration anchors for crisp-set QCA.
```{r Skaaning csqca anchors}
# Loading Skaaning (2011) data from table 3
data("Skaaning_table3")
```

### Analysis of solutions
On the most highly aggregated level of analysis, `sols_robust()` either produces a bar chart plotting the frequency of solutions or a dataframe with solutions and their frequencies. The Â´plot = T` creates a bar chart of solution frequencies in the dataset. The argument `plot_solutions` specifies how many solutions sohuld be plotted with the default being 5 (count always starts with the most frequent solution). Solutions can get long and be too long for plotting on the axes. This is why the solutions are numbered in the plots.
```{r}
# plotting solutions with default setting
sols_robust(Skaaning_table3, plot = T)
# plotting three solutions
sols_robust(Skaaning_table3, plot = T, plot_solutions = 3)
```

If one wants to see what solution is behiind each number, one has to produce the dataframe with the argument `plot = F`. The dataframe always contains all solutions in the data regardless of the frequency.
```{r}
sols_robust(Skaaning_table3, plot = F) -> Skaaning_df
formattable(Skaaning_df)
```



On the second, medium level of aggregation, the solutions are decomposed into their configurations. The `config_upset()` function serves this purpose. This should be used now with the config_upset_h() version of the function.
```{r, eval = F, fig.width = 7, fig.height = 5}
skaaning_conds <- conds_upset(Skaaning_table3, nsets = 200)
skaaning_conds
```

Applying the functions to Krogslund et al. (PA, 2015)
Initially on the naive model 1 (referred to as ka_model_1_sim)

```{r, eval = F}
model_1 <- read.csv("ka_model_1_sim.csv")

#conditions
kcp <- conds_upset(model_1$Configurations, nsets = 200)
conds_upset(model_1$Configurations, nsets = 162)

```


The rest of the models (titled for the sake of clarity as model_n)
model_1 (is the model presented in the chunk above).

```{r,eval=F}
model_2 <- read.csv("ka_model_1_ncut1_error.csv")
model_3 <- read.csv("model_2_ncut1_error.csv")
model_4 <- read.csv("model_2_sim.csv")
model_5 <- read.csv("model_ncut2_error.csv")
model_6 <- read.csv("model_sim.csv")
```

Conditions function
```{r, eval = F}
conds_upset(model_2$Configurations, nsets = 200)
conds_upset(model_3$Configurations, nsets = 500)
conds_upset(model_4$Configurations, nsets = 300)
conds_upset(model_5$Configurations, nsets = 400)
conds_upset(model_6$Configurations, nsets = 500)
```


Configurations applied
```{r, eval = F}
config_upset(model_2$Configurations, nsets = 300)
config_upset(model_3$Configurations, nsets = 300)
config_upset(model_4$Configurations, nsets = 400)
config_upset(model_5$Configurations, nsets = 500)
config_upset(model_6$Configurations, nsets = 400)

```










